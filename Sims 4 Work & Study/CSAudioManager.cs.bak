using System;using System;using System;

using System.Diagnostics;

using CSCore;using System.Diagnostics;using System.Collections.Generic;

using CSCore.Codecs;

using CSCore.SoundOut;using CSCore;using System.Diagnostics;

using CSCore.Streams;

using Sims_4_Work___Study;using CSCore.Codecs;using CSCore;

using Sims_4_Work___Study.Properties;

using CSCore.SoundOut;using CSCore.Codecs;

/// <summary>

/// Gerenciador principal de áudio do aplicativo.using CSCore.Streams;using CSCore.SoundOut;

/// Orquestra a reprodução de músicas usando os serviços especializados.

/// </summary>using Sims_4_Work___Study;using CSCore.Streams;

public class CSAudioManager

{using Sims_4_Work___Study.Properties;using Sims_4_Work___Study;

    private readonly AudioConfiguration config;

    private readonly MusicLibraryManager libraryManager;using Sims_4_Work___Study.Properties;

    private readonly ChannelFadeService fadeService;

    private readonly Random random;/// <summary>



    private ISoundOut outputDevice;/// Gerenciador principal de áudio do aplicativo./// <summary>

    private SimpleMixer mixer;

    private MusicTrack currentTrack;/// Orquestra a reprodução de músicas usando os serviços especializados./// Gerenciador principal de áudio do aplicativo.



    public event EventHandler PlaybackFinished;/// </summary>/// Orquestra a reprodução de músicas usando os serviços especializados.

    public int chanceTarget = Settings.Default.change_channel_chance;

public class CSAudioManager/// </summary>

    public CSAudioManager() : this(AudioConfiguration.Default)

    {{public class CSAudioManager

    }

    // Componentes principais{

    public CSAudioManager(AudioConfiguration configuration)

    {    private readonly AudioConfiguration config;    // Componentes principais

        config = configuration ?? AudioConfiguration.Default;

        libraryManager = new MusicLibraryManager();    private readonly MusicLibraryManager libraryManager;    private readonly AudioConfiguration config;

        fadeService = new ChannelFadeService(config.FadeSteps, config.FadeIntervalMs);

        random = new Random();    private readonly ChannelFadeService fadeService;    private readonly MusicLibraryManager libraryManager;



        InitializeMixer();    private readonly Random random;    private readonly ChannelFadeService fadeService;

        InitializeOutputDevice();

    }    private readonly Random random;



    private void InitializeMixer()    // Dispositivos de áudio

    {

        mixer = new SimpleMixer(config.AudioChannels, config.SampleRate)    private ISoundOut outputDevice;    // Dispositivos de áudio

        {

            FillWithZeros = config.MixerFillWithZeros,    private SimpleMixer mixer;    private ISoundOut outputDevice;

            DivideResult = config.MixerDivideResult

        };    private SimpleMixer mixer;



        mixer.PlaybackFinished += (s, e) =>    // Música atual

        {

            PlaybackFinished?.Invoke(this, EventArgs.Empty);    private MusicTrack currentTrack;    // Música atual

        };

    }    private MusicTrack currentTrack;



    private void InitializeOutputDevice()    // Eventos

    {

        outputDevice = new WasapiOut();    public event EventHandler PlaybackFinished;    // Eventos

    }

    public event EventHandler PlaybackFinished;

    public void SetBasePath(string basePath)

    {    // Configuração de chance de mudança de channel

        libraryManager.Initialize(basePath);

    }    public int chanceTarget = Settings.Default.change_channel_chance;    // Configuração de chance de mudança de channel



    public void LoadRandomMusicFolder()    public int chanceTarget = Settings.Default.change_channel_chance;

    {

        string folderPath = libraryManager.GetNextRandomMusic();    public CSAudioManager() : this(AudioConfiguration.Default)

        LoadMusicFromFolder(folderPath);

    }    {    public CSAudioManager() : this(AudioConfiguration.Default)



    private void LoadMusicFromFolder(string folderPath)    }    {

    {

        Debug.WriteLine($"Carregando música: {folderPath}");    }



        currentTrack = new MusicTrack(folderPath);    public CSAudioManager(AudioConfiguration configuration)



        string[] audioFiles = libraryManager.GetMusicFiles(    {    public CSAudioManager(AudioConfiguration configuration)

            folderPath, 

            config.AudioFileExtension,         config = configuration ?? AudioConfiguration.Default;    {

            config.ChannelsPerTrack);

        libraryManager = new MusicLibraryManager();        config = configuration ?? AudioConfiguration.Default;

        foreach (var filePath in audioFiles)

        {        fadeService = new ChannelFadeService(config.FadeSteps, config.FadeIntervalMs);        libraryManager = new MusicLibraryManager();

            AddChannelToCurrentTrack(filePath);

        }        random = new Random();        fadeService = new ChannelFadeService(config.FadeSteps, config.FadeIntervalMs);



        if (currentTrack.ChannelCount == config.ChannelsPerTrack)        random = new Random();

        {

            int initialChannel = random.Next(config.ChannelsPerTrack);        InitializeMixer();

            currentTrack.SetActiveChannel(initialChannel, config.MaxVolume);

        }        InitializeOutputDevice();        InitializeMixer();

    }

    }        InitializeOutputDevice();

    private void AddChannelToCurrentTrack(string filePath)

    {    }

        IWaveSource audioSource = CodecFactory.Instance.GetCodec(filePath);

    private void InitializeMixer()

        var sampleSource = audioSource

            .ToSampleSource()    {    public void LoadRandomMusicFolder()

            .ToStereo();

        mixer = new SimpleMixer(config.AudioChannels, config.SampleRate)    {

        var volumeSource = new VolumeSource(sampleSource)

        {        {        if (unplayedFolders.Count == 0)

            Volume = config.MinVolume

        };            FillWithZeros = config.MixerFillWithZeros,        {



        var channel = new AudioChannel(filePath, audioSource, volumeSource);            DivideResult = config.MixerDivideResult            ResetUnplayedFolders();



        currentTrack.AddChannel(channel);        };        }

        mixer.AddSource(volumeSource);

    }



    public void InitializePlayback()        mixer.PlaybackFinished += (s, e) =>        string selectedFolder = unplayedFolders[0];

    {

        if (mixer == null)        {

        {

            InitializeMixer();            PlaybackFinished?.Invoke(this, EventArgs.Empty);        if (playingFolder == null)

        }

        };        {

        if (outputDevice == null)

        {    }            playingFolder = selectedFolder;

            InitializeOutputDevice();

        }        }



        outputDevice.Initialize(mixer.ToWaveSource(32));    private void InitializeOutputDevice()

        outputDevice.Play();

    }    {        unplayedFolders.RemoveAt(0);



    public void StartPlayback()        outputDevice = new WasapiOut();

    {

        if (outputDevice == null)    }        Debug.WriteLine("Carregando pasta: " + selectedFolder);

            InitializeOutputDevice();



        if (mixer == null)

            InitializeMixer();    /// <summary>        var flacFiles = Directory.GetFiles(selectedFolder, "*.mp3");



        outputDevice.Initialize(mixer.ToWaveSource(32));    /// Define o diretório base onde as músicas estão armazenadas.        if (flacFiles.Length < 8)

        outputDevice.Play();

    }    /// </summary>        {



    public void OnWindowFocusChanged()    public void SetBasePath(string basePath)            throw new FileNotFoundException($"Pasta {selectedFolder} não tem pelo menos 8 faixas FLAC.");

    {

        int chanceResult = random.Next(100);    {        }

        if (chanceResult >= chanceTarget) 

            return;        libraryManager.Initialize(basePath);



        if (currentTrack == null || currentTrack.ChannelCount < 2)    }        foreach (var filePath in flacFiles.Take(8))

            return;

        {

        if (fadeService.IsFading)

            return;    /// <summary>            AddTrack(filePath);



        int newChannelIndex = currentTrack.GetRandomChannelIndexExcludingCurrent(random);    /// Carrega uma música aleatória da biblioteca.        }



        var fadingOutChannel = currentTrack.ActiveChannel;    /// </summary>

        var fadingInChannel = currentTrack.Channels[newChannelIndex];

    public void LoadRandomMusicFolder()        if (tracks.Count == 8)

        fadeService.StartFade(fadingOutChannel, fadingInChannel, config.MaxVolume, config.MaxVolume);

    {        {

        fadeService.FadeCompleted += (s, e) =>

        {        string folderPath = libraryManager.GetNextRandomMusic();            currentHighlightIndex = random.Next(8);

            if (currentTrack != null)

            {        LoadMusicFromFolder(folderPath);            tracks[currentHighlightIndex].Volume = volumeAlto;

                currentTrack.SetActiveChannel(newChannelIndex, config.MaxVolume);

            }    }        }

        };

    }    }



    public void StopAll()    /// <summary>

    {

        outputDevice?.Stop();    /// Carrega uma música a partir de uma pasta específica.    public void InitializePlayback()

        fadeService?.StopFade();

    }    /// </summary>    {



    public void PausePlayback()    private void LoadMusicFromFolder(string folderPath)        if (mixer == null)

    {

        outputDevice?.Pause();    {        {

    }

        Debug.WriteLine($"Carregando música: {folderPath}");            mixer = new SimpleMixer(2, 44100)

    public void ResumePlayback()

    {            {

        outputDevice?.Play();

    }        // Cria a nova música                FillWithZeros = true,



    public void SetMainTrackVolume(float volume)        currentTrack = new MusicTrack(folderPath);                DivideResult = false

    {

        if (currentTrack != null)            };

        {

            currentTrack.SetActiveChannelVolume(volume);        // Obtém os arquivos de áudio            mixer.PlaybackFinished += (s, e) =>

        }

    }        string[] audioFiles = libraryManager.GetMusicFiles(            {



    public void PreviousSong()            folderPath,                 PlaybackFinished?.Invoke(this, EventArgs.Empty);

    {

        if (!libraryManager.HasPreviousMusic)            config.AudioFileExtension,             };

        {

            Debug.WriteLine("Nenhuma música anterior para reproduzir.");            config.ChannelsPerTrack);        }

            return;

        }



        string previousFolder = libraryManager.GoToPreviousMusic();        // Adiciona cada arquivo como um channel        if (outputDevice == null)

        Debug.WriteLine($"Reproduzindo música anterior: {previousFolder}");

        foreach (var filePath in audioFiles)            outputDevice = new WasapiOut();

        ReloadMusic(previousFolder);

    }        {



    public void NextSong()            AddChannelToCurrentTrack(filePath);        outputDevice.Initialize(mixer.ToWaveSource(32));

    {

        string nextFolder = libraryManager.GoToNextMusic();        }        outputDevice.Play();

        Debug.WriteLine($"Carregando próxima música: {nextFolder}");

    }

        ReloadMusic(nextFolder);

    }        // Seleciona um channel aleatório para ser o ativo



    private void ReloadMusic(string folderPath)        if (currentTrack.ChannelCount == config.ChannelsPerTrack)    /// <summary>

    {

        StopAll();        {    /// Adiciona uma faixa FLAC ao mixer, iniciando com volume mudo (0).

        ClearMixer();

                    int initialChannel = random.Next(config.ChannelsPerTrack);    /// </summary>

        if (currentTrack != null)

        {            currentTrack.SetActiveChannel(initialChannel, config.MaxVolume);    private void AddTrack(string filePath)

            currentTrack.Dispose();

            currentTrack = null;        }    {

        }

    }        IWaveSource reader = CodecFactory.Instance.GetCodec(filePath);

        CreateMixerIfNeeded();

        LoadMusicFromFolder(folderPath);        readers.Add(reader);

        InitializePlayback();

    }    /// <summary>



    public void ClearMixer()    /// Adiciona um channel à música atual.        var source = reader

    {

        if (mixer != null)    /// </summary>            .ToSampleSource()

        {

            mixer.Dispose();    private void AddChannelToCurrentTrack(string filePath)            .ToStereo();

            mixer = null;

        }    {

    }

        // Carrega o arquivo de áudio        var volumeSource = new VolumeSource(source)

    public void CreateMixerIfNeeded()

    {        IWaveSource audioSource = CodecFactory.Instance.GetCodec(filePath);        {

        if (mixer == null)

        {            Volume = volumeMudo

            InitializeMixer();

        }        // Converte para sample source estéreo        };

    }

        var sampleSource = audioSource

    public void ClearAll()

    {            .ToSampleSource()        tracks.Add(volumeSource);

        StopAll();

            .ToStereo();        mixer.AddSource(volumeSource);

        if (outputDevice != null)

        {    }

            outputDevice.Dispose();

            outputDevice = null;        // Cria o volume source (inicia mudo)

        }

        var volumeSource = new VolumeSource(sampleSource)    public void CreateMixerIfNeeded()

        ClearMixer();

        {    {

        if (currentTrack != null)

        {            Volume = config.MinVolume        if (mixer == null)

            currentTrack.Dispose();

            currentTrack = null;        };        {

        }

            mixer = new SimpleMixer(2, 44100)

        fadeService?.Dispose();

    }        // Cria o channel            {



    public void SkipToNearEnd(double secondsBeforeEnd = 5.0)        var channel = new AudioChannel(filePath, audioSource, volumeSource);                FillWithZeros = true,

    {

        if (currentTrack == null)                DivideResult = false

            return;

        // Adiciona ao track e ao mixer            };

        foreach (var channel in currentTrack.Channels)

        {        currentTrack.AddChannel(channel);            mixer.PlaybackFinished += (s, e) =>

            if (channel.AudioSource != null && channel.AudioSource.CanSeek)

            {        mixer.AddSource(volumeSource);            {

                long bytesPerSecond = channel.AudioSource.WaveFormat.BytesPerSecond;

                long newPos = channel.AudioSource.Length - (long)(secondsBeforeEnd * bytesPerSecond);    }                PlaybackFinished?.Invoke(this, EventArgs.Empty);

                

                if (newPos < 0)            };

                    newPos = 0;

    /// <summary>        }

                channel.AudioSource.Position = newPos;

            }    /// Inicializa a reprodução da música atual.    }

        }

    }    /// </summary>

}

    public void InitializePlayback()    public void StartPlayback()

    {    {

        if (mixer == null)        if (outputDevice == null)

        {            outputDevice = new WasapiOut();

            InitializeMixer();

        }        if (mixer == null)

            CreateMixerIfNeeded();

        if (outputDevice == null)

        {        outputDevice.Initialize(mixer.ToWaveSource(32));

            InitializeOutputDevice();        outputDevice.Play();

        }    }



        outputDevice.Initialize(mixer.ToWaveSource(32));    public void ClearMixer()

        outputDevice.Play();    {

    }        if (mixer != null)

        {

    /// <summary>            mixer.Dispose();

    /// Inicia a reprodução.            mixer = null;

    /// </summary>        }

    public void StartPlayback()    }

    {

        if (outputDevice == null)    public void ClearAll()

            InitializeOutputDevice();    {

        if (outputDevice != null)

        if (mixer == null)        {

            InitializeMixer();            outputDevice.Stop();

            outputDevice.Dispose();

        outputDevice.Initialize(mixer.ToWaveSource(32));            outputDevice = null;

        outputDevice.Play();        }

    }        ClearMixer();

        tracks.Clear();

    /// <summary>        readers.Clear();

    /// Chamado quando a janela do Windows perde o foco.    }

    /// Pode alternar para outro channel com base na chance configurada.

    /// </summary>    public void SetBasePath(string assetsPath)

    public void OnWindowFocusChanged()    {

    {        allFolders = Directory.GetDirectories(assetsPath).ToList();

        // Verifica se deve fazer o fade baseado na chance        ResetUnplayedFolders();

        int chanceResult = random.Next(100);    }

        if (chanceResult >= chanceTarget) 

            return;    private void ResetUnplayedFolders()

    {

        if (currentTrack == null || currentTrack.ChannelCount < 2)        allFolders = new List<string>(allFolders);

            return;        Shuffle(allFolders);

        unplayedFolders = new List<string>(allFolders);

        // Já está fazendo fade, ignora        playedFolders = new List<string>();

        if (fadeService.IsFading)    }

            return;    private void Shuffle(List<string> list)

    {

        // Seleciona um novo channel aleatório        for (int i = list.Count - 1; i > 0; i--)

        int newChannelIndex = currentTrack.GetRandomChannelIndexExcludingCurrent(random);        {

            int j = random.Next(i + 1);

        // Obtém os channels envolvidos no fade            (list[i], list[j]) = (list[j], list[i]);

        var fadingOutChannel = currentTrack.ActiveChannel;        }

        var fadingInChannel = currentTrack.Channels[newChannelIndex];    }



        // Inicia o fade    /// <summary>

        fadeService.StartFade(fadingOutChannel, fadingInChannel, config.MaxVolume, config.MaxVolume);    /// Quando ocorre mudança de foco na janela, faz o fade entre a faixa atual e outra aleatória.

    /// </summary>

        // Atualiza o índice do channel ativo após o fade    public void OnWindowFocusChanged()

        fadeService.FadeCompleted += (s, e) =>    {

        {        int chanceResult = random.Next(100);

            if (currentTrack != null)        if (chanceResult >= chanceTarget) return;

            {

                currentTrack.SetActiveChannel(newChannelIndex, config.MaxVolume);        if (tracks.Count < 8) return;

            }

        };        int newIndex;

    }        do

        {

    /// <summary>            newIndex = random.Next(tracks.Count);

    /// Para toda a reprodução.        } while (newIndex == currentHighlightIndex);

    /// </summary>

    public void StopAll()        fadingOutTrack = tracks[currentHighlightIndex];

    {        fadingInTrack = tracks[newIndex];

        outputDevice?.Stop();        currentHighlightIndex = newIndex;

        fadeService?.StopFade();

    }        currentStep = 0;

        if (fadeTimer == null)

    /// <summary>        {

    /// Pausa a reprodução.            fadeTimer = new System.Timers.Timer(fadeIntervalMs);

    /// </summary>            fadeTimer.Elapsed += FadeTimer_Elapsed;

    public void PausePlayback()        }

    {        fadeTimer.Start();

        outputDevice?.Pause();    }

    }

    private void FadeTimer_Elapsed(object sender, ElapsedEventArgs e)

    /// <summary>    {

    /// Retoma a reprodução.        currentStep++;

    /// </summary>

    public void ResumePlayback()        float delta = (volumeAlto - volumeMudo) / fadeSteps;

    {

        outputDevice?.Play();        if (fadingOutTrack != null)

    }        {

            float newVolume = fadingOutTrack.Volume - delta;

    /// <summary>            fadingOutTrack.Volume = Math.Max(volumeMudo, newVolume);

    /// Define o volume do channel ativo.        }

    /// </summary>

    public void SetMainTrackVolume(float volume)        if (fadingInTrack != null)

    {        {

        if (currentTrack != null)            float newVolume = fadingInTrack.Volume + delta;

        {            fadingInTrack.Volume = Math.Min(volumeAlto, newVolume);

            currentTrack.SetActiveChannelVolume(volume);        }

        }

    }        if (currentStep >= fadeSteps)

        {

    /// <summary>            fadeTimer.Stop();

    /// Vai para a música anterior.            if (fadingOutTrack != null)

    /// </summary>                fadingOutTrack.Volume = volumeMudo;

    public void PreviousSong()            if (fadingInTrack != null)

    {                fadingInTrack.Volume = volumeAlto;

        if (!libraryManager.HasPreviousMusic)        }

        {    }

            Debug.WriteLine("Nenhuma música anterior para reproduzir.");

            return;    public void StopAll()

        }    {

        if (outputDevice != null)

        string previousFolder = libraryManager.GoToPreviousMusic();        {

        Debug.WriteLine($"Reproduzindo música anterior: {previousFolder}");            outputDevice.Stop();

        }

        ReloadMusic(previousFolder);    }

    }

    public void SetMainTrackVolume(float volume)

    /// <summary>    {

    /// Vai para a próxima música.        if (currentHighlightIndex >= 0 && currentHighlightIndex < tracks.Count)

    /// </summary>        {

    public void NextSong()            tracks[currentHighlightIndex].Volume = volume;

    {        }

        string nextFolder = libraryManager.GoToNextMusic();    }

        Debug.WriteLine($"Carregando próxima música: {nextFolder}");

    public void PausePlayback()

        ReloadMusic(nextFolder);    {

    }        outputDevice?.Pause();

    }

    /// <summary>

    /// Recarrega uma música específica.    public void ResumePlayback()

    /// </summary>    {

    private void ReloadMusic(string folderPath)        outputDevice?.Play();

    {    }

        StopAll();

        ClearMixer();    public void PreviousSong()

            {

        if (currentTrack != null)        if (playedFolders.Count == 0)

        {        {

            currentTrack.Dispose();            Debug.WriteLine("Nenhuma música anterior para reproduzir.");

            currentTrack = null;            return;

        }        }

        unplayedFolders.Insert(0, playingFolder);

        CreateMixerIfNeeded();        playingFolder = playedFolders.Last();

        LoadMusicFromFolder(folderPath);        playedFolders.RemoveAt(playedFolders.Count - 1);

        InitializePlayback();        Debug.WriteLine("Reproduzindo pasta anterior: " + playingFolder);

    }        ClearMixer();

        CreateMixerIfNeeded();

    /// <summary>        tracks.Clear();

    /// Limpa o mixer atual.        var flacFiles = Directory.GetFiles(playingFolder, "*.mp3");

    /// </summary>        if (flacFiles.Length < 8)

    public void ClearMixer()        {

    {            throw new FileNotFoundException($"Pasta {playingFolder} não tem pelo menos 8 faixas FLAC.");

        if (mixer != null)        }

        {        foreach (var filePath in flacFiles.Take(8))

            mixer.Dispose();        {

            mixer = null;            AddTrack(filePath);

        }        }

    }        if (tracks.Count == 8)

        {

    /// <summary>            currentHighlightIndex = random.Next(8);

    /// Cria um novo mixer se necessário.            tracks[currentHighlightIndex].Volume = volumeAlto;

    /// </summary>            StopAll();

    public void CreateMixerIfNeeded()            InitializePlayback();

    {        }

        if (mixer == null)    }

        {

            InitializeMixer();    public void NextSong()

        }    {

    }        if (unplayedFolders.Count == 0)

        {

    /// <summary>            ResetUnplayedFolders();

    /// Limpa todos os recursos.        }

    /// </summary>        playedFolders.Add(playingFolder);

    public void ClearAll()        string selectedFolder = unplayedFolders[0];

    {        unplayedFolders.RemoveAt(0);

        StopAll();        playingFolder = selectedFolder;

        Debug.WriteLine("Carregando pasta: " + selectedFolder);

        if (outputDevice != null)        ClearMixer();

        {        CreateMixerIfNeeded();

            outputDevice.Dispose();        tracks.Clear();

            outputDevice = null;

        }        var flacFiles = Directory.GetFiles(selectedFolder, "*.mp3");

        if (flacFiles.Length < 8)

        ClearMixer();        {

            throw new FileNotFoundException($"Pasta {selectedFolder} não tem pelo menos 8 faixas FLAC.");

        if (currentTrack != null)        }

        {        foreach (var filePath in flacFiles.Take(8))

            currentTrack.Dispose();        {

            currentTrack = null;            AddTrack(filePath);

        }        }

        if (tracks.Count == 8)

        fadeService?.Dispose();        {

    }            currentHighlightIndex = random.Next(8);

            tracks[currentHighlightIndex].Volume = volumeAlto;

    // ===================================================================            StopAll();

    // MÉTODOS PARA DEBUG            InitializePlayback();

    // ===================================================================        }

    }

    /// <summary>

    /// [DEBUG] Pula para próximo do final da música.    //-----------------------------------------------------------

    /// </summary>    // Métodos para DEBUG

    public void SkipToNearEnd(double secondsBeforeEnd = 5.0)    //-----------------------------------------------------------

    {

        if (currentTrack == null)    public void SkipToNearEnd(double secondsBeforeEnd = 5.0)

            return;    {

        foreach (var reader in readers)

        foreach (var channel in currentTrack.Channels)        {

        {            if (reader.CanSeek)

            if (channel.AudioSource != null && channel.AudioSource.CanSeek)            {

            {                long bytesPerSecond = reader.WaveFormat.BytesPerSecond;

                long bytesPerSecond = channel.AudioSource.WaveFormat.BytesPerSecond;                long newPos = reader.Length - (long)(secondsBeforeEnd * bytesPerSecond);

                long newPos = channel.AudioSource.Length - (long)(secondsBeforeEnd * bytesPerSecond);                if (newPos < 0)

                                    newPos = 0;

                if (newPos < 0)                reader.Position = newPos;

                    newPos = 0;            }

        }

                channel.AudioSource.Position = newPos;    }

            }}

        }
    }
}
